# 3.2 정확한 10진수 계산

## 문제

정확한 10진수 계산을 해야 하고, 부동 소수점을 사용할 때 발생하는 작은 오류를 피하고 싶다.

## 해결

부동 소수점 값에는 10진수를 아주 정확히 표현하지 못한다는 문제가 있다. 심지어 아주 작은 계산을 하더라도 오류가 발생하기도 한다.

```
In [19]: a = 4.2

In [20]: b = 2.1

In [21]: a + b
Out[21]: 6.300000000000001

In [22]: (a + b) == 6.3
Out[22]: False
```

이런 오류료 CPU와 IEEE 754로 부동 소수점 숫자 계싼을 할 떄 필연적으로 발생한다. 파이썬의 부동 소수점 값이 바로 이 표현식을 사용하기 때문에 float를 사용해서는 이 오류를 피할 수 있는 방법이 없다.

하지만 더 정확한 계산을 하고 싶다면( 성능을 희생한다면 ), demical 모듈을 사용해야 한다.

```
In [24]: from decimal import Decimal

In [25]: a = Decimal('4.2')

In [26]: b = Decimal('2.1')

In [27]: a + b
Out[27]: Decimal('6.3')

In [28]: print(a + b)
6.3

In [30]: (a + b) == Decimal('6.3')
Out[30]: True
```

Decimal 객체는 우리가 기대하는 모든 동작(숫자 계싼 포함을)을 정확히 수행한다. 문자열 서식화 함수에 사용하거나 출력하면 마치 일반적인 숫자인 것처럼 보인다.

decimal의 중요한 기능으로 반올림의 자릿수와 같은 계싼적 측면을 조절할 수 있다는 점이 있다.

```
In [31]: from decimal import localcontext

In [32]: a = Decimal('1.3')

In [33]: b = Decimal('1.7')

In [34]: print(a / b)
0.7647058823529411764705882353

In [35]: with localcontext() as ctx:
    ...:     ctx.prec = 3
    ...:     print(a / b)
    ...:
0.765

In [36]: with localcontext() as ctx:
    ...:     ctx.prec = 30
    ...:     print(a / b)
    ...:
0.764705882352941176470588235294
```

## 토론 

1. float가 제공하는 17자리 정확도로 표현하지 못하는 것이 거의 없다. 따라서 부동 소수점에서 발생하는 아주 작은 오류는 무시해도 될 만한 수준이다.
2. decimal 모듈에 비해 float의 실행 속도가 확연히 빠르다.

아주 크고 작은 숫자를 더할 때 발생하는 오류도 조심해야 한다.

```
In [37]: nums = [1.23e+18, 1, -1.23e+18]

In [38]: sum(nums) # 1이 사라진다
Out[38]: 0.0 
```

math.fsum()을 사용하면 더 정확한 계산을 할 수 있다.

```
In [39]: import math

In [40]: math.fsum(nums)
Out[40]: 1.0
```

정말 철저하게 계산을 해야 하는 곳에서만 decimal을 사용하자
